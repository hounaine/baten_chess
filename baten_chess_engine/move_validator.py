"""
validator_dsl.py -- generated by dsl/generate_dsl.py
"""

from typing import Optional, Tuple
from baten_chess_engine.board import Board
ROOK_DIFFS = set(range(1,8)) | {10*i for i in range(1,8)}
KNIGHT_DELTAS = {(1,2),(2,1)}
BISHOP_DIFFS = {9*i for i in range(1,8)} | {11*i for i in range(1,8)}

def is_valid_rook_move(piece: str, src: int, dst: int, state: Board) -> bool:
    # basic checks
    if len(piece) != 2 or piece[1] != 'R':
        return False
    color = piece[0]
    if color != state.turn:
        return False

    diff = abs(src - dst)
    if diff not in ROOK_DIFFS: return False
    if not state.path_clear(src, dst): return False
    # final empty/enemy check if needed
    if not (state.is_empty(dst) or state.is_enemy(dst, color)):
        return False
    return True
def is_valid_knight_move(piece: str, src: int, dst: int, state: Board) -> bool:
    # basic checks
    if len(piece) != 2 or piece[1] != 'N':
        return False
    color = piece[0]
    if color != state.turn:
        return False

    c1,l1 = divmod(src,10)
    c2,l2 = divmod(dst,10)
    if (abs(c1-c2), abs(l1-l2)) not in KNIGHT_DELTAS: return False
    # final empty/enemy check if needed
    if not (state.is_empty(dst) or state.is_enemy(dst, color)):
        return False
    return True
def is_valid_pawn_move(piece: str, src: int, dst: int, state: Board) -> bool:
    # basic checks
    if len(piece) != 2 or piece[1] != 'P':
        return False
    color = piece[0]
    if color != state.turn:
        return False

    c1,l1 = divmod(src,10)
    c2,l2 = divmod(dst,10)
    dc = c2 - c1
    dl = l2 - l1
    # single advance
    if dc==0 and ((color=='w' and dl==1) or (color=='b' and dl==-1)):
        if not state.is_empty(dst): return False
        return True
    # double step
    if dc==0 and ((color=='w' and l1==2 and dl==2) or (color=='b' and l1==7 and dl==-2)):
        mid=(src+dst)//2
        if not(state.is_empty(mid) and state.is_empty(dst)): return False
        return True
    # captures
    if abs(dc)==1 and ((color=='w' and dl==1) or (color=='b' and dl==-1)):
        if state.is_enemy(dst,color) or dst==state.en_passant_target:
            return True
        return False
    return False
    # final empty/enemy check if needed
    return True
def is_valid_bishop_move(piece: str, src: int, dst: int, state: Board) -> bool:
    # basic checks
    if len(piece) != 2 or piece[1] != 'B':
        return False
    color = piece[0]
    if color != state.turn:
        return False

    diff = abs(src - dst)
    if diff not in BISHOP_DIFFS: return False
    if not state.path_clear(src, dst): return False
    # final empty/enemy check if needed
    if not (state.is_empty(dst) or state.is_enemy(dst, color)):
        return False
    return True
def is_valid_queen_move(piece: str, src: int, dst: int, state: Board) -> bool:
    # basic checks
    if len(piece) != 2 or piece[1] != 'Q':
        return False
    color = piece[0]
    if color != state.turn:
        return False

    diff = abs(src - dst)
    if not (diff in ROOK_DIFFS or diff in BISHOP_DIFFS): return False
    if not state.path_clear(src, dst): return False
    # final empty/enemy check if needed
    return True
def is_valid_king_move(piece: str, src: int, dst: int, state: Board) -> bool:
    # basic checks
    if len(piece) != 2 or piece[1] != 'K':
        return False
    color = piece[0]
    if color != state.turn:
        return False

    diff = abs(src - dst)
    if diff not in {1,9,10,11,2}: return False
    # final empty/enemy check if needed
    return True

def is_valid_move(piece: str, src: int, dst: int, state: Board, last_move: Optional[Tuple[int,int]] = None) -> bool:
    """
    Dispatch function for DSL-based validation.
    """
    color = piece[0]
    ptype = piece[1]
    if ptype == 'R':
        return is_valid_rook_move(piece, src, dst, state)
    if ptype == 'N':
        return is_valid_knight_move(piece, src, dst, state)
    if ptype == 'P':
        return is_valid_pawn_move(piece, src, dst, state)
    if ptype == 'B':
        return is_valid_bishop_move(piece, src, dst, state)
    if ptype == 'Q':
        return is_valid_queen_move(piece, src, dst, state)
    if ptype == 'K':
        return is_valid_king_move(piece, src, dst, state)
    return False
