"""
validator_dsl.py -- generated by dsl/generate_dsl.py
"""

from typing import Optional, Tuple
from baten_chess_engine.board import Board

# Differences or deltas for each piece type
ROOK_DIFFS      = set(range(1, 8))               | {10 * i for i in range(1, 8)}
KNIGHT_DELTAS   = {(1, 2), (2, 1)}
BISHOP_DIFFS    = {9 * i for i in range(1, 8)}   | {11 * i for i in range(1, 8)}


def is_valid_rook_move(piece: str, src: int, dst: int, state: Board) -> bool:
    """Cinématique pure de la tour (vertical/horizontal + obstruction)."""
    if len(piece) != 2 or piece[1] != 'R':
        return False
    color = piece[0]
    if color != state.turn:
        return False

    col1, row1 = divmod(src, 10)
    col2, row2 = divmod(dst, 10)
    diff = abs(src - dst)

    # Vertical strict : même colonne, delta rangée 1..7
    if diff in range(1, 8) and col1 == col2:
        pass
    # Horizontal strict : même rangée, delta colonne 10..70
    elif diff in {10 * i for i in range(1, 8)} and row1 == row2:
        pass
    else:
        return False

    # Pas d'obstacle entre src et dst
    if not state.path_clear(src, dst):
        return False
    # Case vide ou occupée par un ennemi
    if not (state.is_empty(dst) or state.is_enemy(dst, color)):
        return False

    return True


def is_valid_knight_move(piece: str, src: int, dst: int, state: Board) -> bool:
    if len(piece) != 2 or piece[1] != 'N':
        return False
    color = piece[0]
    if color != state.turn:
        return False

    c1, r1 = divmod(src, 10)
    c2, r2 = divmod(dst, 10)
    if (abs(c1 - c2), abs(r1 - r2)) not in KNIGHT_DELTAS:
        return False
    if not (state.is_empty(dst) or state.is_enemy(dst, color)):
        return False

    return True


def is_valid_pawn_move(piece: str, src: int, dst: int, state: Board) -> bool:
    if len(piece) != 2 or piece[1] != 'P':
        return False
    color = piece[0]
    if color != state.turn:
        return False

    c1, r1 = divmod(src, 10)
    c2, r2 = divmod(dst, 10)
    dc = c2 - c1
    dr = r2 - r1

    # Avancée simple
    if dc == 0 and ((color == 'w' and dr == 1) or (color == 'b' and dr == -1)):
        return state.is_empty(dst)

    # Double-pas depuis la rangée initiale
    if dc == 0 and ((color == 'w' and r1 == 2 and dr == 2) or (color == 'b' and r1 == 7 and dr == -2)):
        mid = (src + dst) // 2
        return state.is_empty(mid) and state.is_empty(dst)

    # Prise diagonale ou en passant
    if abs(dc) == 1 and ((color == 'w' and dr == 1) or (color == 'b' and dr == -1)):
        return state.is_enemy(dst, color) or dst == state.en_passant_target

    return False


def is_valid_bishop_move(piece: str, src: int, dst: int, state: Board) -> bool:
    if len(piece) != 2 or piece[1] != 'B':
        return False
    color = piece[0]
    if color != state.turn:
        return False

    r1, c1 = divmod(src, 10)
    r2, c2 = divmod(dst, 10)
    dr = r2 - r1
    dc = c2 - c1

    # Doit être une vraie diagonale
    if abs(dr) != abs(dc) or abs(dr) == 0:
        return False

    diff = abs(src - dst)
    if diff not in BISHOP_DIFFS:
        return False

    if not state.path_clear(src, dst):
        return False
    if not (state.is_empty(dst) or state.is_enemy(dst, color)):
        return False

    return True


def is_valid_queen_move(piece: str, src: int, dst: int, state: Board) -> bool:
    if len(piece) != 2 or piece[1] != 'Q':
        return False
    color = piece[0]
    if color != state.turn:
        return False

    r1, c1 = divmod(src, 10)
    r2, c2 = divmod(dst, 10)
    dr = r2 - r1
    dc = c2 - c1
    diff = abs(src - dst)

    # Ligne/colonne (comme la tour)
    if (diff in range(1, 8) and c1 == c2) or (diff in {10 * i for i in range(1, 8)} and r1 == r2):
        pass
    # Diagonale (comme le fou)
    elif abs(dr) == abs(dc) and diff in BISHOP_DIFFS:
        pass
    else:
        return False

    if not state.path_clear(src, dst):
        return False
    if not (state.is_empty(dst) or state.is_enemy(dst, color)):
        return False

    return True


def is_valid_king_move(piece: str, src: int, dst: int, state: Board) -> bool:
    if len(piece) != 2 or piece[1] != 'K':
        return False
    color = piece[0]
    if color != state.turn:
        return False

    diff = abs(src - dst)
    # 1 pas dans 8 directions ou roque (diff = 2)
    if diff not in {1, 9, 10, 11, 2}:
        return False
    if not (state.is_empty(dst) or state.is_enemy(dst, color)):
        return False

    return True


def is_valid_move_dsl(piece: str,
                      src: int,
                      dst: int,
                      state: Board,
                      last_move: Optional[Tuple[int, int]] = None) -> bool:
    """
    Point d’entrée unique pour la validation via DSL.
    """
    ptype = piece[1]
    if ptype == 'R':
        return is_valid_rook_move(piece, src, dst, state)
    if ptype == 'N':
        return is_valid_knight_move(piece, src, dst, state)
    if ptype == 'P':
        return is_valid_pawn_move(piece, src, dst, state)
    if ptype == 'B':
        return is_valid_bishop_move(piece, src, dst, state)
    if ptype == 'Q':
        return is_valid_queen_move(piece, src, dst, state)
    if ptype == 'K':
        return is_valid_king_move(piece, src, dst, state)
    return False
