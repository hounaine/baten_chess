# validator_dsl.py -- generated by dsl/generate_dsl.py

from typing import Optional, Tuple
from baten_chess_engine.board import Board

# Ensembles de différences
ROOK_DIFFS   = set(range(1, 8))            | {10 * i for i in range(1, 8)}
BISHOP_DIFFS = {9 * i for i in range(1, 8)} | {11 * i for i in range(1, 8)}

# Deltas pour le cavalier (colonne, rangée)
KNIGHT_DELTAS = {(1, 2), (2, 1)}

def is_valid_rook_move(piece: str, src: int, dst: int, state: Board) -> bool:
    """Cinématique pure de la tour (ligne/colonne + obstruction)."""
    if len(piece) != 2 or piece[1] != 'R':
        return False

    row1, col1 = divmod(src, 10)
    row2, col2 = divmod(dst, 10)
    diff = abs(src - dst)

    # Mouvement horizontal strict
    if diff in range(1, 8) and row1 == row2:
        pass
    # Mouvement vertical strict
    elif diff in {10 * i for i in range(1, 8)} and col1 == col2:
        pass
    else:
        return False

    # Vérifier qu'aucune pièce n'obstrue le chemin
    return state.path_clear(src, dst)

def is_valid_knight_move(piece: str, src: int, dst: int, state: Board) -> bool:
    """Cinématique pure du cavalier (L-shape)."""
    if len(piece) != 2 or piece[1] != 'N':
        return False

    row1, col1 = divmod(src, 10)
    row2, col2 = divmod(dst, 10)
    delta = (abs(row2 - row1), abs(col2 - col1))
    return delta in KNIGHT_DELTAS

def is_valid_pawn_move(piece: str, src: int, dst: int, state: Board) -> bool:
    """
    Cinématique pure du pion :
      - avancée 1 ou 2 cases,
      - captures diagonales (y compris en-passant flaggé dans state.en_passant_target).
    Ne gère pas la promotion.
    """
    if len(piece) != 2 or piece[1] != 'P':
        return False

    row1, col1 = divmod(src, 10)
    row2, col2 = divmod(dst, 10)
    dr = row2 - row1
    dc = col2 - col1

    # Avancée simple
    if dc == 0 and dr in (+1, -1):
        return True

    # Double-pas depuis la rangée initiale
    if dc == 0 and dr in (+2, -2) and ((row1 == 2 and dr == +2) or (row1 == 7 and dr == -2)):
        # Vérification de l'intermédiaire se fait au niveau des règles
        return True

    # Prise diagonale ou en-passant (flag)
    if abs(dc) == 1 and dr in (+1, -1):
        # On autorise le tracé ; la présence d’un ennemi ou du en_passant_target
        # est contrôlée dans le moteur de règles
        return True

    return False

def is_valid_bishop_move(piece: str, src: int, dst: int, state: Board) -> bool:
    """Cinématique pure du fou (diagonale + obstruction)."""
    if len(piece) != 2 or piece[1] != 'B':
        return False

    row1, col1 = divmod(src, 10)
    row2, col2 = divmod(dst, 10)
    dr = row2 - row1
    dc = col2 - col1

    # Doit être une vraie diagonale non nulle
    if abs(dr) != abs(dc) or dr == 0:
        return False

    diff = abs(src - dst)
    if diff not in BISHOP_DIFFS:
        return False

    return state.path_clear(src, dst)

def is_valid_queen_move(piece: str, src: int, dst: int, state: Board) -> bool:
    """Cinématique pure de la dame (tour + fou)."""
    if len(piece) != 2 or piece[1] != 'Q':
        return False

    row1, col1 = divmod(src, 10)
    row2, col2 = divmod(dst, 10)
    dr = row2 - row1
    dc = col2 - col1
    diff = abs(src - dst)

    # Cas tour : ligne ou colonne
    if (diff in range(1, 8) and row1 == row2) or \
       (diff in {10 * i for i in range(1, 8)} and col1 == col2):
        return state.path_clear(src, dst)

    # Cas fou : diagonale
    if abs(dr) == abs(dc) and diff in BISHOP_DIFFS:
        return state.path_clear(src, dst)

    return False

def is_valid_king_move(piece: str, src: int, dst: int, state: Board) -> bool:
    """Cinématique pure du roi (un pas et roque géré en rules)."""
    if len(piece) != 2 or piece[1] != 'K':
        return False

    diff = abs(src - dst)
    # 1 case dans les 8 directions (sans roque)
    return diff in {1, 9, 10, 11}

def is_valid_move_dsl(
    piece: str,
    src: int,
    dst: int,
    state: Board,
    last_move: Optional[Tuple[int, int]] = None
) -> bool:
    """
    Point d'entrée unique pour la validation cinématique via la DSL.
    """
    ptype = piece[1]
    if ptype == 'R':
        return is_valid_rook_move(piece, src, dst, state)
    if ptype == 'N':
        return is_valid_knight_move(piece, src, dst, state)
    if ptype == 'P':
        return is_valid_pawn_move(piece, src, dst, state)
    if ptype == 'B':
        return is_valid_bishop_move(piece, src, dst, state)
    if ptype == 'Q':
        return is_valid_queen_move(piece, src, dst, state)
    if ptype == 'K':
        return is_valid_king_move(piece, src, dst, state)
    return False
