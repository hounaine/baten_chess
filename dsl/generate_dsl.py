# dsl/generate_dsl.py

import yaml
import os

# Directory containing all spec_*.yaml files
tSPEC_DIR = 'dsl'
# Output path: place generated move_validator into core module
OUT_FILE = os.path.join("..", "baten_chess_engine", "core", "move_validator.py")

# Piece specifications: per-type checks and constants
PIECE_SPECS = {
    'R': {
        'name': 'rook',
        'check': [
            "diff = abs(src - dst)",
            "if diff not in ROOK_DIFFS: return False",
            "if not state.path_clear(src, dst): return False",
        ],
        'constants': [
            "ROOK_DIFFS = set(range(1,8)) | {10*i for i in range(1,8)}"
        ]
    },
    'N': {
        'name': 'knight',
        'check': [
            "c1,l1 = divmod(src,10)",
            "c2,l2 = divmod(dst,10)",
            "if (abs(c1-c2), abs(l1-l2)) not in KNIGHT_DELTAS: return False",
        ],
        'constants': [
            "KNIGHT_DELTAS = {(1,2),(2,1)}"
        ]
    },
    'P': {
        'name': 'pawn',
        'check': [
            "c1,l1 = divmod(src,10)",
            "c2,l2 = divmod(dst,10)",
            "dc = c2 - c1",
            "dl = l2 - l1",
            "# single advance",
            "if dc==0 and ((color=='w' and dl==1) or (color=='b' and dl==-1)):",
            "    if not state.is_empty(dst): return False",
            "    return True",
            "# double step",
            "if dc==0 and ((color=='w' and l1==2 and dl==2) or (color=='b' and l1==7 and dl==-2)):",
            "    mid=(src+dst)//2",
            "    if not(state.is_empty(mid) and state.is_empty(dst)): return False",
            "    return True",
            "# captures",
            "if abs(dc)==1 and ((color=='w' and dl==1) or (color=='b' and dl==-1)):",
            "    if state.is_enemy(dst,color) or dst==state.en_passant_target:",
            "        return True",
            "    return False",
            "return False"
        ],
        'constants': []
    },
    'B': {
        'name': 'bishop',
        'check': [
            "diff = abs(src - dst)",
            "if diff not in BISHOP_DIFFS: return False",
            "if not state.path_clear(src, dst): return False",
        ],
        'constants': [
            "BISHOP_DIFFS = {9*i for i in range(1,8)} | {11*i for i in range(1,8)}"
        ]
    },
    'Q': {
        'name': 'queen',
        'constants': [],  # reuse rook and bishop diffs
        'check': [
            "diff = abs(src - dst)",
            "if not (diff in ROOK_DIFFS or diff in BISHOP_DIFFS): return False",
            "if not state.path_clear(src, dst): return False",
        ]
    },
    'K': {
        'name': 'king',
        'constants': [],
        'check': [
            "diff = abs(src - dst)",
            "if diff not in {1,9,10,11,20}: return False",  # 20 for castling
        ]
    },
}

HEADER = '''"""
validator_dsl.py -- generated by dsl/generate_dsl.py
"""

from typing import Optional, Tuple
from baten_chess_engine.core.board import Board
'''

DISPATCH_HEADER = '''
@@ def is_valid_move(piece: str, src: int, dst: int, state: Board, last_move: Optional[Tuple[int,int]] = None) -> bool:
    """
    Dispatch function for DSL-based validation.
    """
    color = piece[0]
    ptype = piece[1]
'''

def gen_function(ptype, spec, spec_yaml):
    """
    Génère la fonction is_valid_{piece}_move intégrant :
      - les checks cinématiques (spec['check'])
      - les guards globales et par-transition
      - les actions 'do' de chaque transition
    """
    # Build guard map
    guard_map = {g['name']: g['code'] for g in spec_yaml.get('guards', [])}
    transitions = spec_yaml.get('transitions', [])

    name = f"is_valid_{spec['name']}_move"
    lines = []
    lines.append(f"def {name}(piece: str, src: int, dst: int, state: Board) -> bool:")
    lines.append("    # Basic validity checks")
    lines.append("    if len(piece) != 2 or piece[1] != {!r}:".format(ptype))
    lines.append("        return False")
    lines.append("    color = piece[0]")
    lines.append("    if color != state.turn:")
    lines.append("        return False")
    lines.append("")

    # Inject global guards
    if guard_map:
        lines.append("    # Global guards")
        for name_g, code in guard_map.items():
            lines.append(f"    # {name_g}")
            lines.append(f"    if not ({code}): return False")
        lines.append("")

    # Kinematic checks
    lines.append("    # Movement kinematics")
    for chk in spec['check']:
        if chk.startswith("#"):
            lines.append(f"    {chk}")
        else:
            lines.append(f"    {chk}")
    lines.append("")

    # Per-transition logic
    if transitions:
        lines.append("    # Transition-specific actions")
        for trans in transitions:
            tname = trans.get('name', '<transition>')
            lines.append(f"    # Transition: {tname}")
            # transition-level guards
            for g in trans.get('guards', []):
                code = guard_map.get(g)
                if code:
                    lines.append(f"    # {g}")
                    lines.append(f"    if not ({code}): return False")
            # do actions
            for action in trans.get('do', []):
                lines.append(f"    {action}")
            lines.append("    return True")
        lines.append("")

    # Default occupancy check for non-pawn moves
    if ptype in ('R','B','N','Q','K'):
        lines.append("    # Final occupancy check")
        lines.append("    if not (state.is_empty(dst) or state.is_enemy(dst, color)): return False")
        lines.append("")

    lines.append("    return False\n")
    return "\n".join(lines)


def main():
    specs = [(pt, sp) for pt, sp in PIECE_SPECS.items()]

    with open(OUT_FILE, 'w', encoding='utf-8') as fout:
        fout.write(HEADER)
        # Write constants
        for _, spec in specs:
            for const in spec.get('constants', []):
                fout.write(const + "\n")
        fout.write("\n")
        # Generate each validator
        for ptype, spec in specs:
            yaml_path = os.path.join(tSPEC_DIR, f"spec_{spec['name']}.yaml")
            spec_yaml = {}
            if os.path.exists(yaml_path):
                spec_yaml = yaml.safe_load(open(yaml_path, 'r', encoding='utf-8')) or {}
            func_code = gen_function(ptype, spec, spec_yaml)
            fout.write(func_code)

        # Dispatcher
        fout.write(DISPATCH_HEADER)
        for ptype, spec in specs:
            fout.write(f"    if ptype == {ptype!r}:\n")
            fout.write(f"        return is_valid_{spec['name']}_move(piece, src, dst, state)\n")
        fout.write("    return False\n")

    print(f"Generated {OUT_FILE} with {len(specs)} piece validators.")

if __name__ == '__main__':
    main()
#     if not is_valid_move(piece, src, dst, board):
#         return jsonify({"error": errors['invalid_move']}), 400