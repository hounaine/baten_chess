# dsl/generate_dsl.py

import yaml
import os

SPEC_DIR = 'dsl'
OUT_FILE = 'baten_chess_engine/validator_dsl.py'

# Pour chaque pièce, on va décrire son set de différences ou sa logique spéciale
PIECE_SPECS = {
    'R': {
        'name': 'rook',
        'check': [
            "diff = abs(src - dst)",
            "if diff not in ROOK_DIFFS: return False",
            "if not state.path_clear(src, dst): return False",
        ],
        'constants': [
            "ROOK_DIFFS = set(range(1,8)) | {10*i for i in range(1,8)}"
        ]
    },
    'N': {
        'name': 'knight',
        'check': [
            "c1,l1 = divmod(src,10)",
            "c2,l2 = divmod(dst,10)",
            "if (abs(c1-c2), abs(l1-l2)) not in KNIGHT_DELTAS: return False",
        ],
        'constants': [
            "KNIGHT_DELTAS = {(1,2),(2,1)}"
        ]
    },
    'P': {
        'name': 'pawn',
        'check': [
            "c1,l1 = divmod(src,10)",
            "c2,l2 = divmod(dst,10)",
            "dc = c2 - c1",
            "dl = l2 - l1",
            "# single advance",
            "if dc==0 and ((color=='w' and dl==1) or (color=='b' and dl==-1)):",
            "    if not state.is_empty(dst): return False",
            "    return True",
            "# double step",
            "if dc==0 and ((color=='w' and l1==2 and dl==2) or (color=='b' and l1==7 and dl==-2)):",
            "    mid=(src+dst)//2",
            "    if not(state.is_empty(mid) and state.is_empty(dst)): return False",
            "    return True",
            "# captures",
            "if abs(dc)==1 and ((color=='w' and dl==1) or (color=='b' and dl==-1)):",
            "    if state.is_enemy(dst,color) or dst==state.en_passant_target:",
            "        return True",
            "    return False",
            "return False"
        ],
        'constants': []
    },
    'B': {
        'name': 'bishop',
        'check': [
            "diff = abs(src - dst)",
            "if diff not in BISHOP_DIFFS: return False",
            "if not state.path_clear(src, dst): return False",
        ],
        'constants': [
            "BISHOP_DIFFS = {9*i for i in range(1,8)} | {11*i for i in range(1,8)}"
        ]
    },
        'Q': {
        'name': 'queen',
        'constants': [],  # on réutilise ROOK_DIFFS et BISHOP_DIFFS
        'check': [
            "diff = abs(src - dst)",
            "if not (diff in ROOK_DIFFS or diff in BISHOP_DIFFS): return False",
            "if not state.path_clear(src, dst): return False",
        ]
    },
    'K': {
        'name': 'king',
        'constants': [],  
        'check': [
            "diff = abs(src - dst)",
            "if diff not in {1,9,10,11,2}: return False",  # 2 pour le roque
            # (plus tard : vérif. cases intermédiaires non attaquées)
        ]
    },
}

HEADER = '''"""
validator_dsl.py -- generated by dsl/generate_dsl.py
"""

from typing import Optional, Tuple
from baten_chess_engine.board import Board
'''

DISPATCH_HEADER = '''
def is_valid_move_dsl(piece: str, src: int, dst: int, state: Board, last_move: Optional[Tuple[int,int]] = None) -> bool:
    """
    Dispatch function for DSL-based validation.
    """
    color = piece[0]
    ptype = piece[1]
'''

def gen_function(ptype, spec):
    name = f"is_valid_{spec['name']}_move"
    lines = []
    lines.append(f"def {name}(piece: str, src: int, dst: int, state: Board) -> bool:")
    lines.append("    # basic checks")
    lines.append("    if len(piece) != 2 or piece[1] != {!r}:".format(ptype))
    lines.append("        return False")
    lines.append("    color = piece[0]")
    lines.append("    if color != state.turn:")
    lines.append("        return False")
    # insert constants later
    lines.append("")
    # insert check logic
    for chk in spec['check']:
        if chk.startswith("#"):
            lines.append("    " + chk)
        else:
            lines.append("    " + chk)
    lines.append("    # final empty/enemy check if needed")
    # pour R,B,N déjà couvert, mais P gère tout
    if ptype in ('R','B','N'):
        lines.append("    if not (state.is_empty(dst) or state.is_enemy(dst, color)):")
        lines.append("        return False")
    lines.append("    return True\n")
    return "\n".join(lines)

def main():
    # Collect specs présent
    specs = []
    # Utiliser l'ordre de la dict
    for ptype, spec in PIECE_SPECS.items():
        specs.append((ptype, spec))
    # Écrire le fichier
    with open(OUT_FILE, 'w', encoding='utf-8') as fout:
        fout.write(HEADER)
        # écrire CONSTS
        for ptype, spec in specs:
            for const in spec['constants']:
                fout.write(const + "\n")
        fout.write("\n")
        # écrire chaque fonction
        for ptype, spec in specs:
            fout.write(gen_function(ptype, spec))
        # dispatcher
        fout.write(DISPATCH_HEADER)
        for ptype, spec in specs:
            fout.write(f"    if ptype == {ptype!r}:\n")
            fout.write(f"        return is_valid_{spec['name']}_move(piece, src, dst, state)\n")
        fout.write("    return False\n")

    print(f"Generated {OUT_FILE} with {len(specs)} piece validators.")

if __name__ == '__main__':
    main()
